# Missing Patient Problem


## Question

Every patient who want to go to the Akdeniz University hospital on a particular day must make an appointment beforehand. For each day, patients with appointments are given distinct sequential patient numbers starting from 1 so that the patient with the first appointment gets the patient number 1, the second one gets 2 and so on. Unfortunately, the patients come to their appointments in a totally random order. Also, some patients do not come to their appointments. Assume that n patients got patient numbers on a particular day and one of them did not come to his/her appointment. Patient numbers of patients that showed up are stored in an array A of size n − 1 where the patient numbers are ordered with respect to their arrival times. We want to design an  (n) complexity algorithm to find the patient with the lowest patient number who did not show up for his/her appointment. For example, let n = 12 with A = [12, 7, 10, 9, 5, 4, 11, 1, 6, 8, 2]. Then, the algorithm must return 3.

**(a)** Understand the problem, design an algorithm satisfying the O(n) complexity, write the pseudocode of your algorithm and then implement it as a method in Java programming language. Hint: Use divide-and-conquer. Try to collect smaller patient numbers to the left and bigger numbers to the right. In your solution, you MUST utilize and modify the Partition algorithm that is used by QuickSort (solutions that do not use partitioning and recursion, such as subtracting the sum of the elements in A from the sum of the integers up-to n will not get any point). You should distribute the patient numbers to both partitions in a clever way so that the complexity could be O(n). You should enforce the Partition algorithm to partition almost from the half by assigning a tricky pivot each time the modified Partition is called. If needed, you can also let the Partition algorithm take additional parameter(s). After partitioning, decide which part might have the missing patient and continue conquering that part recursively. Note that sorting the array will not help due to the time-complexity constraint. However, you will still need a recursive partitioning.

**(b)** Formulate the recurrence of your algorithm and discuss why it is O(n). Then, inside your main method, you will generate sequential arrays of sizes m = 10K, 20K, 30K, 40K, 50K, 60K, 70K, 80K, 90K, 100K and randomly remove one element to obtain the corresponding A’s. Then, you will run your method on each array by putting timers just before and after the function call to calculate a running time (i.e. take the difference of finish and start times). Finally, plot the calculated running times as a function of n and discuss whether the resulting plot is as expected.